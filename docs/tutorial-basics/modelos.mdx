---
sidebar_position: 5
---

# Modelos

## ¿Qué es un modelo?

Los modelos en Laravel y otros frameworks ORM proporcionan una capa de abstracción que permite a los desarrolladores interactuar con la base de datos utilizando un lenguaje de programación orientado a objetos en lugar de SQL. 

Al utilizar un modelo, el desarrollador puede trabajar con los datos de la base de datos como si fueran objetos en lugar de filas en una tabla. Esto hace que el código sea más legible y fácil de mantener, ya que se pueden utilizar nombres de método y propiedades significativos en lugar de nombres de columna en la base de datos.

Además, los modelos permiten definir relaciones entre tablas, como una relación uno a muchos o muchos a muchos. Por ejemplo, si tienes una tabla de usuarios y una tabla de publicaciones, puedes definir una relación en el modelo de usuarios que indica que un usuario tiene muchas publicaciones. Esto facilita el acceso a los datos relacionados y permite realizar consultas complejas con facilidad.

Otra ventaja de utilizar modelos es que Laravel proporciona muchas herramientas integradas para trabajar con ellos. Por ejemplo, puedes utilizar métodos como `all()`, `find()`, `create()` y `delete()` para realizar operaciones comunes en la base de datos con una sintaxis simple y legible. También puedes utilizar el motor de consultas de Laravel para crear consultas complejas utilizando una sintaxis similar a SQL pero más amigable para el lenguaje de programación orientado a objetos.

En resumen, los modelos son una parte esencial de la arquitectura de Laravel y otros frameworks ORM. Proporcionan una capa de abstracción que simplifica la interacción con la base de datos y hace que el código sea más legible y fácil de mantener. Además, permiten definir relaciones entre tablas y proporcionan herramientas integradas para trabajar con ellos.

En Laravel, los modelos se utilizan para representar una tabla de la base de datos. El nombre del modelo debe ser el mismo que el nombre de la tabla, pero en singular y en CamelCase. Por ejemplo, si tienes una tabla llamada "users", el modelo correspondiente se llamaría "User".

Laravel utiliza convenciones para relacionar los modelos con las tablas de la base de datos. Por defecto, el modelo busca la tabla con el mismo nombre en plural, pero esta convención se puede cambiar si es necesario. Además, Laravel permite especificar manualmente el nombre de la tabla en caso de que necesites utilizar un nombre diferente.

Una vez que se ha definido el modelo, puedes utilizar los métodos del modelo para interactuar con la tabla correspondiente en la base de datos. Por ejemplo, el método `all()` devuelve una colección de todos los registros de la tabla, el método `find()` busca un registro por su clave primaria, el método `create()` crea un nuevo registro y el método `update()` actualiza un registro existente.

Además, puedes utilizar las relaciones en los modelos para definir relaciones entre las tablas. Por ejemplo, si tienes una tabla de usuarios y una tabla de publicaciones, puedes definir una relación en el modelo de usuarios que indica que un usuario tiene muchas publicaciones. Esto facilita el acceso a los datos relacionados y permite realizar consultas complejas con facilidad.

En resumen, los modelos en Laravel se relacionan con las tablas de la base de datos de forma automática utilizando convenciones basadas en el nombre del modelo y la tabla. Los modelos permiten interactuar con los datos de la tabla utilizando un lenguaje de programación orientado a objetos y proporcionan herramientas integradas para trabajar con ellos. Además, permiten definir relaciones entre tablas y realizar consultas complejas con facilidad.

## ¿Cómo se relacionan los modelos con las tablas de la base de datos?

En Laravel, los modelos se utilizan para representar una tabla de la base de datos. El nombre del modelo debe ser el mismo que el nombre de la tabla, pero en singular y en CamelCase. Por ejemplo, si tienes una tabla llamada "users", el modelo correspondiente se llamaría "User".

Laravel utiliza convenciones para relacionar los modelos con las tablas de la base de datos. Por defecto, el modelo busca la tabla con el mismo nombre en plural, pero esta convención se puede cambiar si es necesario. Además, Laravel permite especificar manualmente el nombre de la tabla en caso de que necesites utilizar un nombre diferente.

Una vez que se ha definido el modelo, puedes utilizar los métodos del modelo para interactuar con la tabla correspondiente en la base de datos. Por ejemplo, el método `all()` devuelve una colección de todos los registros de la tabla, el método `find()` busca un registro por su clave primaria, el método `create()` crea un nuevo registro y el método `update()` actualiza un registro existente.

Además, puedes utilizar las relaciones en los modelos para definir relaciones entre las tablas. Por ejemplo, si tienes una tabla de usuarios y una tabla de publicaciones, puedes definir una relación en el modelo de usuarios que indica que un usuario tiene muchas publicaciones. Esto facilita el acceso a los datos relacionados y permite realizar consultas complejas con facilidad.

En resumen, los modelos en Laravel se relacionan con las tablas de la base de datos de forma automática utilizando convenciones basadas en el nombre del modelo y la tabla. Los modelos permiten interactuar con los datos de la tabla utilizando un lenguaje de programación orientado a objetos y proporcionan herramientas integradas para trabajar con ellos. Además, permiten definir relaciones entre tablas y realizar consultas complejas con facilidad.

## Cómo se definen los modelos en Laravel

En Laravel, los modelos son clases PHP que representan las tablas de la base de datos y se utilizan para interactuar con los datos en la base de datos. Aquí te muestro cómo definir un modelo en Laravel:

**Paso 1:** Crear un nuevo archivo PHP para el modelo
En la carpeta `app/Models` de tu proyecto Laravel, puedes crear un nuevo archivo PHP para el modelo. Por convención, los modelos en Laravel suelen estar en el namespace `App\Models`. Puedes nombrar el archivo con el nombre del modelo en singular y en notación camelCase. Por ejemplo, si tu modelo representa una tabla de usuarios, puedes crear un archivo llamado `User.php`.

**Paso 2:** Definir la clase del modelo
Dentro del archivo del modelo, debes definir la clase del modelo extendiendo la clase base `Illuminate\Database\Eloquent\Model`. Por ejemplo:

```php
namespace App\Models;

use Illuminate\Database\Eloquent\Model;

class User extends Model
{
    // Aquí se define la clase del modelo
}
```

**Paso 3:** Definir las propiedades y métodos del modelo
Dentro de la clase del modelo, puedes definir las propiedades y métodos necesarios para interactuar con la tabla de la base de datos. Algunas de las propiedades y métodos más comunes son:

- `$table`: Propiedad que define el nombre de la tabla en la base de datos a la que el modelo está asociado. Por defecto, Laravel asume que el nombre de la tabla es el nombre del modelo en plural en notación snake_case, pero puedes especificar un nombre de tabla diferente si es necesario.

- `$fillable` y `$guarded`: Propiedades que definen los campos que pueden ser llenados masivamente mediante el método `create()` o `update()`. `$fillable` especifica los campos que están permitidos, mientras que `$guarded` especifica los campos que están protegidos y no pueden ser llenados masivamente.

- Relaciones: Puedes definir las relaciones del modelo con otros modelos utilizando los métodos `hasMany()`, `belongsTo()`, `hasManyThrough()`, entre otros. Esto permite establecer relaciones entre tablas de la base de datos y acceder a los registros relacionados de forma fácil y conveniente.

- Otros métodos: También puedes definir otros métodos en el modelo según tus necesidades, como por ejemplo, mutadores y accesores para manipular los datos antes de guardarlos en la base de datos o al acceder a ellos.

**Paso 4:** Utilizar el modelo en el código
Una vez que has definido el modelo, puedes utilizarlo en tu código para interactuar con los datos en la base de datos. Puedes utilizar los métodos del modelo para realizar consultas, insertar, actualizar o eliminar registros en la base de datos de forma sencilla y elegante.

:::info Crear el modelo con artisan
Claro, para crear un modelo en Laravel utilizando Artisan, debes ejecutar el siguiente comando en la terminal en la raíz de tu proyecto:

```
php artisan make:model NombreDelModelo
```

Reemplaza "NombreDelModelo" por el nombre que quieras darle a tu modelo. Una vez ejecutado el comando, se creará un archivo en la carpeta "app/Models" con el nombre que hayas especificado, con el siguiente código básico:

```php
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class NombreDelModelo extends Model
{
    use HasFactory;
}
```

A partir de aquí, podrás agregar las propiedades y métodos necesarios para definir la estructura y comportamiento de tu modelo en función de tus necesidades, como hemos veremos en proximos temas.
:::

En resumen, para definir un modelo en Laravel, necesitas crear un archivo PHP en la carpeta `app/Models`, definir la clase del modelo que extienda de `Illuminate\Database\Eloquent\Model`, y luego definir las propiedades y métodos necesarios para interactuar con los datos en la base de datos. Una vez definido, puedes utilizar el modelo en tu código para interactuar con la base de datos de manera fácil y conveniente.

## Propiedades especiales de los modelos

### protected $table

En Laravel, cada modelo se corresponde con una tabla de la base de datos. Por defecto, Laravel asume que el nombre de la tabla será el nombre del modelo en minúsculas y en plural. Sin embargo, es posible especificar el nombre de la tabla correspondiente a un modelo en particular a través de la propiedad `$table` del modelo.

La propiedad `$table` es una propiedad protegida que se utiliza para definir el nombre de la tabla correspondiente al modelo en particular. Por ejemplo, si tienes un modelo llamado `Book`, y la tabla correspondiente en la base de datos se llama `libros`, puedes especificar el nombre de la tabla en el modelo de la siguiente manera:

```php
class Book extends Model
{
    protected $table = 'libros';
}
```
:::info Importante
Por defecto Laravel si no se especifica esta propiedad, asumira que la tabla
de BB.DD correspondiente es igual al  nombre del modelo más una s al final y en minusculas.
:::

De esta manera, Laravel utilizará la tabla `libros` en lugar de la tabla `books` por defecto.

La propiedad `$table` también es útil si necesitas trabajar con una tabla que no sigue las convenciones de nombres de Laravel o si necesitas trabajar con múltiples conexiones de bases de datos.

En resumen, la propiedad `$table` es una propiedad protegida de los modelos de Laravel que se utiliza para definir el nombre de la tabla correspondiente al modelo en particular.

### Propiedad fillable

La propiedad `$fillable` es otra propiedad protegida de los modelos que se utiliza para especificar qué atributos de un modelo pueden ser asignados de forma masiva. Cuando se crea un nuevo registro en la base de datos utilizando la función `create()` o la función `fill()`, se pueden asignar múltiples valores a la vez utilizando un arreglo asociativo. Sin embargo, por razones de seguridad, no todos los atributos de un modelo deben ser asignados masivamente.

Por defecto, todos los atributos de un modelo son "protegidos" y no pueden ser asignados masivamente. Para permitir la asignación masiva de un atributo en particular, debes incluirlo en la propiedad `$fillable`. Por ejemplo, si tienes un modelo `User` con los atributos `name`, `email` y `password`, pero solo quieres permitir la asignación masiva del `name` y del `email`, puedes especificar esto en el modelo de la siguiente manera:

```php
class User extends Model
{
    protected $fillable = ['name', 'email'];
}
```

De esta manera, solo los atributos `name` y `email` pueden ser asignados masivamente utilizando la función `create()` o la función `fill()`, mientras que el atributo `password` se mantiene "protegido".

La propiedad `$fillable` es una medida de seguridad importante para evitar la asignación masiva de datos no deseados a la base de datos. Por lo tanto, es importante ser cuidadoso al utilizar esta propiedad y solo permitir la asignación masiva de los atributos que sean realmente necesarios.

### Propiedad guarded

La propiedad `$guarded` es otra propiedad protegida de los modelos de Eloquent en Laravel que se utiliza para especificar qué atributos no pueden ser asignados masivamente. Es decir, los atributos que se especifiquen en la propiedad `$guarded` no se podrán asignar utilizando la función `create()` o la función `fill()`, pero sí se pueden asignar de forma individual.

Por defecto, la propiedad `$guarded` está vacía, lo que significa que todos los atributos del modelo son "fillable" y se pueden asignar masivamente. Sin embargo, a veces es útil especificar ciertos atributos que nunca deberían ser asignados masivamente, incluso si no están en la propiedad `$fillable`.

Por ejemplo, si tienes un modelo `User` con los atributos `name`, `email`, `password` y `admin`, y deseas que el atributo `admin` nunca sea asignado masivamente, puedes especificarlo en la propiedad `$guarded` de la siguiente manera:

```php
class User extends Model
{
    protected $fillable = ['name', 'email', 'password'];
    protected $guarded = ['admin'];
}
```

En este caso, todos los atributos excepto `admin` son "fillable" y se pueden asignar masivamente. El atributo `admin` está "guarded" y no se puede asignar masivamente. Sin embargo, el atributo `admin` todavía se puede asignar de forma individual utilizando la función `setAttribute()`.

En general, es importante tener en cuenta que la asignación masiva puede ser una vulnerabilidad de seguridad si no se maneja correctamente, y es recomendable utilizar la propiedad `$fillable` o la propiedad `$guarded` para proteger los atributos del modelo de la asignación masiva no deseada.

### Propiedad primarykey

La propiedad `$primaryKey` se utiliza para indicar el nombre de la columna que se utilizará como clave primaria en la tabla de la base de datos asociada al modelo de Eloquent. Por defecto, Laravel asume que la clave primaria es una columna llamada "id". Sin embargo, en algunos casos puede ser necesario utilizar una columna con un nombre diferente como clave primaria, y es ahí donde entra en juego `$primaryKey`.

Por ejemplo, si queremos que la clave primaria sea una columna llamada "codigo_producto" en lugar de "id", podemos establecer la propiedad `$primaryKey` en el modelo de la siguiente manera:

```php
class Producto extends Model
{
    protected $primaryKey = 'codigo_producto';
}
```

De esta forma, Eloquent utilizará la columna "codigo_producto" como clave primaria en lugar de "id". Es importante destacar que, si se utiliza una columna diferente a "id" como clave primaria, es necesario indicarlo al momento de realizar relaciones entre tablas en la base de datos.

### Propiedad keyType

La propiedad `$keyType` se utiliza en los modelos de Eloquent de Laravel para especificar el tipo de datos de la clave primaria de la tabla asociada al modelo. Por defecto, Laravel asume que la clave primaria es un campo de tipo entero (`integer`), pero en algunos casos puede ser necesario utilizar otro tipo de datos para la clave primaria.

Si se quiere definir un tipo de datos diferente para la clave primaria, se puede utilizar la propiedad `$keyType` en el modelo de la siguiente forma:

```php
class Usuario extends Model
{
    protected $keyType = 'string';
}
```

En este ejemplo, se está indicando que el tipo de datos de la clave primaria de la tabla asociada al modelo `Usuario` es una cadena de texto (`string`) en lugar de un número entero por defecto.

Es importante mencionar que al utilizar un tipo de datos diferente para la clave primaria, se debe asegurar que las relaciones definidas en el modelo estén configuradas para utilizar el mismo tipo de datos en las claves foráneas, de lo contrario pueden surgir errores de integridad referencial.

### Propiedad incrementing

La propiedad `$incrementing` es una propiedad de los modelos de Eloquent en Laravel que se utiliza para indicar si la clave primaria de la tabla asociada al modelo es un número autoincremental (`true`) o no (`false`).

Por defecto, Laravel asume que la clave primaria de la tabla es un número autoincremental, por lo que la propiedad `$incrementing` se establece en `true` automáticamente. Si se desea utilizar una clave primaria que no sea autoincremental, se debe establecer la propiedad `$incrementing` en `false`.

```php
class Usuario extends Model
{
    protected $primaryKey = 'codigo';
    public $incrementing = false;
}
```

En este ejemplo, se está indicando que la clave primaria de la tabla asociada al modelo `Usuario` se llama `codigo` y que no es un número autoincremental.

Es importante mencionar que si se establece la propiedad `$incrementing` en `false`, también se debe establecer la propiedad `$keyType` con el tipo de dato correspondiente a la clave primaria, ya que Laravel no podrá inferir automáticamente el tipo de datos de la clave primaria.

### Propiedad timestamps

La propiedad `$timestamps` es una propiedad de los modelos de Eloquent en Laravel que se utiliza para indicar si la tabla asociada al modelo tiene las columnas `created_at` y `updated_at` para el registro de la fecha y hora de creación y actualización de los registros.

Por defecto, Laravel asume que la tabla asociada al modelo tiene estas dos columnas, por lo que la propiedad `$timestamps` se establece en `true` automáticamente. Si se desea desactivar esta funcionalidad, se debe establecer la propiedad `$timestamps` en `false`.

```php
class Usuario extends Model
{
    public $timestamps = false;
}
```

En este ejemplo, se está indicando que la tabla asociada al modelo `Usuario` no tiene las columnas `created_at` y `updated_at`, por lo que no se utilizará la funcionalidad de registro automático de fechas y horas de creación y actualización.

Es importante mencionar que si se utiliza la funcionalidad de registro automático de fechas y horas de creación y actualización, Laravel espera que las columnas `created_at` y `updated_at` de la tabla asociada al modelo sean del tipo `timestamp`, a menos que se especifique lo contrario mediante la propiedad `$dateFormat`.

### Propiedad dateFormat

La propiedad `$dateFormat` es una propiedad de los modelos de Eloquent en Laravel que se utiliza para indicar el formato de las fechas almacenadas en las columnas `created_at` y `updated_at` de la tabla asociada al modelo, en caso de utilizar la funcionalidad de registro automático de fechas y horas.

Por defecto, Laravel asume que el formato de fecha utilizado es el formato ISO 8601, es decir, `Y-m-d\TH:i:sP`. Si se desea cambiar este formato, se debe establecer la propiedad `$dateFormat` en el formato deseado.

```php
class Usuario extends Model
{
    protected $dateFormat = 'd/m/Y H:i:s';
}
```

En este ejemplo, se está indicando que las fechas almacenadas en las columnas `created_at` y `updated_at` de la tabla asociada al modelo `Usuario` se almacenan en el formato `d/m/Y H:i:s`. Esto es útil si se desea utilizar un formato de fecha diferente al predeterminado por Laravel.

### Propiedad coonection

La propiedad `$connection` es una propiedad de los modelos de Eloquent en Laravel que se utiliza para indicar la conexión de base de datos que se utilizará para interactuar con la tabla asociada al modelo.

Por defecto, Laravel utiliza la conexión de base de datos predeterminada para interactuar con las tablas de la base de datos. Sin embargo, en algunas ocasiones se puede necesitar interactuar con una conexión diferente, por ejemplo, cuando se está trabajando con múltiples bases de datos.

```php
class Usuario extends Model
{
    protected $connection = 'conexion_alternativa';
}
```

En este ejemplo, se está indicando que la tabla asociada al modelo `Usuario` debe interactuar con la conexión de base de datos llamada `conexion_alternativa` en lugar de la conexión de base de datos predeterminada. Es importante destacar que se debe asegurar que la conexión definida en la propiedad `$connection` esté configurada correctamente en el archivo `config/database.php`.

:::info Como se configura el archivo **config/database**
En el archivo `config/database.php` se encuentran las configuraciones de las conexiones de base de datos que se pueden utilizar en la aplicación. Por defecto, Laravel define una conexión de base de datos por defecto y puede definir conexiones adicionales.

Para configurar una nueva conexión de base de datos, se debe agregar una nueva entrada al arreglo de conexiones en el archivo `config/database.php`. La entrada debe contener la información necesaria para establecer la conexión, como el controlador de la base de datos, el host, el nombre de la base de datos, el nombre de usuario y la contraseña. Por ejemplo:

```php
'connections' => [

    'mysql' => [
        'driver' => 'mysql',
        'host' => env('DB_HOST', '127.0.0.1'),
        'port' => env('DB_PORT', '3306'),
        'database' => env('DB_DATABASE', 'forge'),
        'username' => env('DB_USERNAME', 'forge'),
        'password' => env('DB_PASSWORD', ''),
        'charset' => 'utf8mb4',
        'collation' => 'utf8mb4_unicode_ci',
        'prefix' => '',
        'strict' => true,
        'engine' => null,
    ],

    'conexion_alternativa' => [
        'driver' => 'mysql',
        'host' => env('DB_HOST_ALT', '127.0.0.1'),
        'port' => env('DB_PORT_ALT', '3306'),
        'database' => env('DB_DATABASE_ALT', 'forge'),
        'username' => env('DB_USERNAME_ALT', 'forge'),
        'password' => env('DB_PASSWORD_ALT', ''),
        'charset' => 'utf8mb4',
        'collation' => 'utf8mb4_unicode_ci',
        'prefix' => '',
        'strict' => true,
        'engine' => null,
    ],

],
```

En este ejemplo, se ha definido una nueva conexión de base de datos llamada `conexion_alternativa` que utiliza las variables de entorno `DB_HOST_ALT`, `DB_PORT_ALT`, `DB_DATABASE_ALT`, `DB_USERNAME_ALT` y `DB_PASSWORD_ALT` para establecer la conexión.

Una vez que se ha definido la conexión en el archivo `config/database.php`, se puede utilizar la propiedad `$connection` en un modelo de Eloquent para indicar qué conexión se debe utilizar para interactuar con la tabla asociada al modelo.
:::

### Propiedad casts

La propiedad `casts` es utilizada en los modelos de Eloquent para 
especificar cómo se deben castear o convertir los valores de los 
atributos de la base de datos a tipos de datos de PHP. 
Esto nos permite trabajar con los atributos de la base de datos
como si fueran tipos de datos nativos de PHP en nuestro código, 
y Laravel se encarga de la conversión automáticamente. 
Las opciones de cast que se pueden usar son `integer`, `real`,
 `float`, `double`, `string`, `boolean`, `object`, `array`, 
 `collection`, `date`, `datetime`, y `timestamp`. 
 La propiedad `casts` debe ser un array asociativo en el que 
 las claves son los nombres de los atributos de la base de datos, 
 y los valores son las opciones de cast correspondientes.

:::info Ejemplo
Supongamos que tenemos una tabla `users` en la que queremos almacenar un campo `settings` que contenga datos en formato JSON. Podemos definir en nuestro modelo `User` la propiedad `casts` de la siguiente manera:

```bash
protected $casts = [
    'settings' => 'array',
];
```

De esta manera, cuando se recuperan los datos del campo 
`settings`, Laravel automáticamente convertirá el valor de 
JSON a un array PHP. Lo mismo ocurre cuando se asigna un valor 
a ese campo: si le pasamos un array PHP, 
Laravel automáticamente lo convertirá a JSON antes de guardarlo 
en la base de datos. Esto nos permite trabajar con datos 
en formato array en nuestro código, y no tener que preocuparnos 
por la conversión de JSON.
:::

## Creando los modelos

## ¿Qué es Elocuent?
![Descripcion de la imagen"](/assets/images/orm.png

Eloquent es el ORM (Object-Relational Mapping) integrado en Laravel, que permite trabajar con las bases de datos de manera objetual. Es decir, Eloquent permite interactuar con las tablas de la base de datos a través de modelos en lugar de escribir consultas SQL manualmente. Cada modelo de Eloquent representa una tabla de la base de datos y proporciona métodos para interactuar con la información almacenada en la tabla. Con Eloquent, se pueden realizar operaciones comunes de CRUD (Crear, Leer, Actualizar y Borrar) de manera fácil y sencilla.

:::tip CRUD con Eloquent
Aquí hay algunos comandos básicos de Eloquent:

$model = new ModelName: Crea una nueva instancia del modelo.

$model->save(): Guarda un nuevo registro en la base de datos.

ModelName::create([data]): Crea un nuevo registro en la base de datos con los datos especificados.

ModelName::find($id): Obtiene un registro en base a su identificador.
:::

No se preocupe si de momento no entiende estos comandos los iremos viendo a medida que vallamos realizando este proyecto.
Para más información consulte la [documentación oficial](https://laravel.com/docs/9.x/readme)

## ¿Cómo crear un modelo?

Para crear un modelo en Laravel, se puede utilizar el comando de Artisan en la terminal:

```bash
php artisan make:model NombreDelModelo
```

Este comando creará un archivo en la carpeta app con el nombre especificado. A continuación, se puede agregar la lógica y atributos del modelo en este archivo.

Por ejemplo, si queremos crear un modelo para una tabla de productos, podemos ejecutar el siguiente comando:

```bash
php artisan make:model Producto
```

Este comando creará un archivo Producto.php en la carpeta app con la siguiente estructura básica:

```js
<?php

namespace App;

use Illuminate\Database\Eloquent\Model;

class Producto extends Model
{
    //
}
```

Después de crear el modelo, se pueden agregar los atributos y métodos necesarios para interactuar con la tabla correspondiente en la base de datos.çç

## Relaciones en Elocuent(Conceptos)

:::tip Uno a uno
En Laravel, una relación "uno a uno" significa que un registro de una tabla está asociado con exactamente un registro en otra tabla. Por ejemplo, un usuario puede tener un solo perfil, y un perfil puede ser de un solo usuario.

Para definir una relación "uno a uno" en Laravel, primero debes crear los modelos para las tablas implicadas en la relación. Luego, debes usar el método hasOne en el modelo que representa la tabla con la clave foránea y el método belongsTo en el modelo que representa la tabla principal.

Aquí hay un ejemplo de cómo crear una relación "uno a uno" entre las tablas de usuarios y perfiles:

```js
Copy code
// Archivo User.php
class User extends Model
{
    public function profile()
    {
        return $this->hasOne('App\Profile');
    }
}

// Archivo Profile.php
class Profile extends Model
{
    public function user()
    {
        return $this->belongsTo('App\User');
    }
}
```
Luego, puedes acceder a la información del perfil de un usuario de la siguiente manera:

```js
$user = User::find(1);
$profile = $user->profile;
```
Esto te permitirá acceder a los atributos del perfil asociado con un usuario determinado.
:::

:::tip Uno a muchos
En Laravel Eloquent, una relación de uno a muchos se establece en un modelo mediante el uso del método "hasMany".

Por ejemplo, si tienes un modelo "User" y un modelo "Order", y cada usuario puede tener muchos pedidos, la relación sería:

```js title="Relación uno a muchos"
class User extends Model
{
    public function orders()
    {
        return $this->hasMany(Order::class);
    }
}
```

Entonces, puedes acceder a los pedidos de un usuario de la siguiente manera:

```js
$user = User::find(1);
$orders = $user->orders;
```

También puedes personalizar la clave foránea en la relación, por ejemplo:

```js
class Order extends Model
{
    public function user()
    {
        return $this->belongsTo(User::class, 'user_id');
    }
}
```

Esto significa que Eloquent buscará una columna "user_id" en la tabla de "orders" para hacer la relación con la tabla de "users".
:::

:::tip Muchos a muchos
En Laravel Eloquent, una relación de muchos a muchos se establece mediante el uso del método "belongsToMany".

Por ejemplo, si tienes un modelo "User" y un modelo "Role", y cada usuario puede tener varios roles y cada rol puede ser asignado a varios usuarios, la relación sería:

```js
class User extends Model
{
    public function roles()
    {
        return $this->belongsToMany(Role::class);
    }
}
```

```js
class Role extends Model
{
    public function users()
    {
        return $this->belongsToMany(User::class);
    }
}
```

Entonces, puedes acceder a los roles de un usuario de la siguiente manera:

```js
$user = User::find(1);
$roles = $user->roles;
```

Y puedes acceder a los usuarios de un rol de la siguiente manera:

```bash
$role = Role::find(1);
$users = $role->users;
```

Por defecto, Eloquent buscará una tabla intermedia con nombres en plural en orden alfabético de las dos tablas relacionadas, por ejemplo, "role_user". Sin embargo, puedes especificar un nombre personalizado para la tabla intermedia utilizando el segundo argumento en el método "belongsToMany", por ejemplo:

```js
return $this->belongsToMany(Role::class, 'user_roles');
```
:::

:::tip Uno a muchos polimórfica

¡Por supuesto! Aquí te dejo una redacción sobre las relaciones uno a muchos polimórficas en Eloquent:

En Eloquent, una relación uno a muchos polimórfica permite que un modelo tenga una relación "uno a muchos" con varios modelos diferentes. Esto es útil cuando quieres tener una única tabla de relación para varias entidades diferentes en lugar de tener tablas separadas para cada relación.

Para establecer una relación uno a muchos polimórfica, debes utilizar los métodos `morphTo()` y `morphMany()` en tus modelos. El método `morphTo()` se utiliza en el modelo que puede tener varias relaciones "uno a muchos", mientras que el método `morphMany()` se utiliza en los modelos que pueden tener una relación "muchos a uno".

Por ejemplo, supongamos que tienes un modelo `Comment` y varios modelos diferentes que pueden ser comentados, como `Post` y `Video`. Para establecer una relación uno a muchos polimórfica, puedes agregar el siguiente método `comments()` al modelo `Post` y al modelo `Video`:

```
public function comments()
{
    return $this->morphMany('App\Models\Comment', 'commentable');
}
```

Este método indica que el modelo `Post` o `Video` puede tener muchos comentarios a través de la relación `commentable`.

A continuación, en el modelo `Comment`, debes agregar el siguiente método `commentable()` para establecer la relación inversa:

```
public function commentable()
{
    return $this->morphTo();
}
```

Este método indica que el modelo `Comment` puede pertenecer a cualquier modelo que tenga una relación "uno a muchos" polimórfica a través del campo `commentable_id` y `commentable_type`.

Ahora puedes acceder a los comentarios de un `Post` o un `Video` utilizando el método `comments()` y puedes acceder al modelo al que pertenece un comentario utilizando el método `commentable()`. Por ejemplo:

```
$post = Post::find(1);
$comments = $post->comments; // Obtener todos los comentarios del post
$comment = Comment::find(1);
$commentable = $comment->commentable; // Obtener el modelo (Post o Video) al que pertenece el comentario
```

En resumen, la relación uno a muchos polimórfica en Eloquent permite que un modelo tenga varias relaciones "uno a muchos" con diferentes modelos, lo que puede ser útil para simplificar la estructura de la base de datos y hacer que el código sea más fácil de mantener.
:::

:::tip Muchos a muchos polimórfica

¡Claro! Aquí te dejo una explicación sobre la relación muchos a muchos polimórfica en Eloquent:

En Eloquent, una relación muchos a muchos polimórfica te permite establecer una relación "muchos a muchos" entre varios modelos diferentes a través de una única tabla de relación polimórfica. Esto es útil cuando tienes varias entidades diferentes que pueden tener muchas instancias de otra entidad y deseas evitar la creación de múltiples tablas de relación.

Para establecer una relación muchos a muchos polimórfica, debes utilizar los métodos `morphToMany()` y `morphedByMany()` en tus modelos. El método `morphToMany()` se utiliza en el modelo que puede tener muchas instancias de otra entidad, mientras que el método `morphedByMany()` se utiliza en el modelo que puede ser utilizado por muchas instancias de otros modelos.

Por ejemplo, supongamos que tienes un modelo `Tag` y varios modelos diferentes que pueden tener muchas etiquetas, como `Post` y `Video`. Para establecer una relación muchos a muchos polimórfica, puedes agregar el siguiente método `tags()` al modelo `Post` y al modelo `Video`:

```
public function tags()
{
    return $this->morphToMany('App\Models\Tag', 'taggable');
}
```

Este método indica que el modelo `Post` o `Video` puede tener muchas etiquetas a través de la relación `taggable`.

A continuación, en el modelo `Tag`, debes agregar el siguiente método `taggable()` para establecer la relación inversa:

```
public function taggable()
{
    return $this->morphedByMany('App\Models\Post', 'taggable');
}
```

Este método indica que el modelo `Tag` puede pertenecer a cualquier modelo que tenga una relación muchos a muchos polimórfica a través de la tabla de relación `taggables` y la columna `taggable_id` y `taggable_type`.

Ahora puedes acceder a las etiquetas de un `Post` o un `Video` utilizando el método `tags()` y puedes acceder a los modelos que tienen una etiqueta específica utilizando el método `taggable()`. Por ejemplo:

```
$post = Post::find(1);
$tags = $post->tags; // Obtener todas las etiquetas del post
$tag = Tag::find(1);
$taggable = $tag->taggable; // Obtener todos los modelos (Post o Video) que tienen la etiqueta
```

En resumen, la relación muchos a muchos polimórfica en Eloquent te permite establecer una relación "muchos a muchos" entre varios modelos diferentes a través de una única tabla de relación polimórfica, lo que puede ser útil para simplificar la estructura de la base de datos y hacer que el código sea más fácil de mantener.
:::

## Tinker

Tinker es una herramienta de **REPL (Read-Eval-Print Loop)** de Laravel que te permite interactuar con tu aplicación de Laravel desde la consola. Con Tinker, puedes ejecutar código PHP, consultar y modificar la información en la base de datos, y ejecutar otros comandos relacionados con Laravel.

Para usar **Tinker**, abre la consola en tu proyecto de Laravel y ejecuta el comando php artisan tinker. Una vez que se abra la sesión de Tinker, puedes escribir cualquier código PHP y ver los resultados en tiempo real. Por ejemplo, puedes consultar información de la base de datos, crear nuevos registros y modificar registros existentes.

Aquí hay algunos ejemplos de lo que puedes hacer con Tinker:

Consultar información de una tabla:

```js
>>> App\Models\Producto::all()
```

Crear un nuevo registro:

```js
>>> $producto = new App\Models\Producto;
>>> $producto->nombre = "Producto 1";
>>> $producto->save()
```

Modificar un registro existente:

```js
>>> $producto = App\Models\Producto::find(1);
>>> $producto->nombre = "Producto actualizado";
>>> $producto->save()
```

Tinker es una herramienta muy útil para probar código rápidamente y ver los resultados sin tener que recargar la página o escribir código adicional en tu aplicación de Laravel. ¡Disfruta!

## Modelos
### Categoría

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Categoria
```

:::tip Importante
El nombre del modelo debe empezar en mayúscula y estar en singular, pues Eloquent va a buscar la tabla correspondiente al modelo añadiendo una s al final.
En este caso al modelo Categoria le corresponde la tabla categorias. Más adelante cuando llegue el caso estudiaremos como cambiar este comportamiento.
:::

Una vez ejecutado el comando edite el siguiente fichero:
**app\Models\Categoria.php**

Sustituye el contenido por el siguiente código PHP:

```js title="app\Models\Categoria.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Categoria extends Model
{
    use HasFactory;
    protected $fillable = ['nombre','descripcion'];
    public function subcategorias(){
        return $this->hasMany('App\Models\Subcategoria');

    }
}
```

En el ejemplo anterior se crea un modelo en Laravel llamado **"Categoria"** que representa una tabla de categorías en la base de datos. Este modelo es una clase que extiende de la clase "Model" de Eloquent, lo que significa que tiene todas las funcionalidades y propiedades necesarias para interactuar con la tabla **"categorías"** en la base de datos.

La propiedad **"fillable"** especifica los campos que pueden ser rellenados por asignación masiva, es decir, aquellos campos que pueden ser modificados a través de un array o objeto. En este caso, los campos "nombre" y **"descripcion"** son los únicos que pueden ser modificados.

El método \***\*subcategorias"** define una relación de uno a muchos con la tabla "subcategorías". Esta relación significa que una categoría puede tener muchas subcategorías, y que cada subcategoría pertenece a una sola categoría. La relación se define usando el método "hasMany", que indica que la clase "Categoria" tiene muchas subcategorías. El argumento de "hasMany" es una cadena con el nombre de la clase **"Subcategoria"**.

Esta relación permite acceder a las subcategorías de una categoría dada usando el método **"subcategorias"**, por ejemplo:

```js
$categoria = App\Models\Categoria::find(1);

foreach ($categoria->subcategorias as $subcategoria) {
    echo $subcategoria->nombre;
}
```

<p align="center">
  <img src="/assets/images/categoria.png" alt="Descripción de la imagen"/>
</p>
Este código busca una categoría con ID 1 y luego imprime el nombre de todas sus subcategorías.

### Subcategoría

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Subcategoria
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Subcategoria"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Subcategoria.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Subcategoria extends Model
{
    use HasFactory;

    protected $fillable = [
        'nombre',
        'descripcion',
        'categoria_id'
    ];

    public function categoria(){
        return $this->belongsTo('App\Models\Categoria');
    }

    public function productos(){
        return $this->hasMany('App\Models\Producto');
    }
}
```

El modelo utiliza la función **"HasFactory"** que permite crear fábricas de objetos para probar y realizar pruebas en el modelo.

La propiedad "$fillable" define los campos que se pueden asignar masivamente en la base de datos y está compuesta por los campos **"nombre"**, **"descripción"** y **"categoria_id"**.

La función "categoria()" es una relación **"belongsTo"** que indica que una subcategoría pertenece a una sola categoria. La relación se establece con el modelo "Categoria" de la aplicación.

La función **"productos()"** es una relación **"hasMany"** que indica que una subcategoría puede tener varios productos asociados a ella. La relación se establece con el modelo _"Producto"_ de la aplicación.

### Producto

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Producto
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Producto"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Producto.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Producto extends Model
{
    use HasFactory;
    protected $table="productos";
    

    protected $fillable = [
        'nombre',
        'descripcion',
        'precio',
        'imagen',
        'subcategoria_id',
        'iva_id',
        'marca_id'
    ];

    public function subcategoria(){
        return $this->belongsTo('App\Models\Subcategoria');
    }

    public function iva(){
        return $this->belongsTo('App\Models\Iva');
    }
    public function marca(){
        return $this->belongsTo('App\Models\Marca');
    }
    public function oferta(){
        return $this->belongsTo('App\Models\Oferta');
    }
    //Relacion muchos a muchos
    public function proveedores(){
        return $this->belongsToMany(Producto::class);
    }
}
```
Este este código de un modelo **"Producto"** en Laravel utilizando Eloquent. En este código se establecen relaciones uno a muchos con los modelos **"Subcategoria", "Iva", "Marca"** y **"Oferta"**, así como también una relación muchos a muchos con el modelo **"Proveedor"**.

La propiedad "table" especifica el nombre de la tabla en la base de datos que almacenará los datos de los productos. La propiedad **"fillable"** especifica los campos que pueden ser rellenados y almacenados en la base de datos cuando se crea o actualiza un producto.

Los métodos **"subcategoria"**, **"iva"**, **"marca"** y **"oferta"** definen las relaciones uno a muchos con los modelos correspondientes. Por ejemplo, el método **"subcategoria"** devuelve una instancia del modelo **"Subcategoria"** al que pertenece un producto.

El método **"proveedores"** define la relación muchos a muchos con el modelo **"Proveedor"**, que permite que un producto tenga muchos proveedores y que un proveedor pueda proveer muchos productos.

Estos métodos se utilizan para acceder a los datos relacionados, por ejemplo:

```js
$product = Producto::find(1);
$subcategory = $product->subcategoria;
$iva = $product->iva;
$brand = $product->marca;
$offer = $product->oferta;
$suppliers = $product->proveedores;
```
### Iva

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Iva
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Iva"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Iva.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Iva extends Model
{
    use HasFactory;

    protected $fillable = ['tanto_porciento','nombre'];
    
    public function productos(){
        return $this->hasMany('App\Models\Producto');
        
    }
}
```
Este es un ejemplo de código de un modelo **"Iva"** en Laravel utilizando Eloquent. En este código se establece una relación uno a muchos con el modelo **"Producto"**.

La propiedad **"fillable"** especifica los campos que pueden ser rellenados y almacenados en la base de datos cuando se crea o actualiza un registro de iva.

El método **"productos"** define la relación uno a muchos con el modelo **"Producto"**. Este método devuelve una colección de todos los productos que pertenecen a un registro de iva.

Estos métodos se utilizan para acceder a los datos relacionados, por ejemplo:

```js
$iva = Iva::find(1);
$products = $iva->productos;
```
### Marca
Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Marca
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Marca"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Marca.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Marca extends Model
{
    protected $fillable = ['nombre'];
    use HasFactory;

    function productos(){
        return $this->hasMany('App\Models\Producto');    
    }

}
```
Este es un ejemplo de código de un modelo **"Marca"** en Laravel utilizando Eloquent. En este código se establece una relación uno a muchos con el modelo **"Producto"**.

La propiedad **"fillable"** especifica los campos que pueden ser rellenados y almacenados en la base de datos cuando se crea o actualiza un registro de marca.

El método **"productos"** define la relación uno a muchos con el modelo **"Producto"**. Este método devuelve una colección de todos los productos que pertenecen a un registro de marca.

Estos métodos se utilizan para acceder a los datos relacionados, por ejemplo:

```js
$marca = Marca::find(1);
$products = $marca->productos;
```
### Oferta

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Oferta
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Oferta"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Oferta.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Oferta extends Model
{
    use HasFactory;
    protected $fillable = [
        'precio',
        'descripcion',
        'fecha_ini',
        'fecha_fin',
        'producto_id'
    ];

    function productos(){
        return $this->hasMany('App\Models\Producto');    
    }
}
```
Este es un ejemplo de código de un modelo **"Oferta"** en Laravel utilizando Eloquent. En este código se establece una relación uno a muchos con el modelo "Producto".

La propiedad **"fillable"** especifica los campos que pueden ser rellenados y almacenados en la base de datos cuando se crea o actualiza un registro de oferta.

El método **"productos"** define la relación uno a muchos con el modelo **"Producto"**. Este método devuelve una colección de todos los productos que pertenecen a un registro de oferta.

Estos métodos se utilizan para acceder a los datos relacionados, por ejemplo:

```js
$oferta = Oferta::find(1);
$products = $oferta->productos;
```

### Provincia

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Provincia
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Provincia"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Provincia.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Provincia extends Model
{
    protected $fillable = [
        'codigo',
        'nombre'
       
    ];
    use HasFactory;
}
```
Este es un modelo de Laravel para una tabla de **"Provincias"**. La clase extiende de **Illuminate\Database\Eloquent\Model**, lo que significa que está siendo utilizada como un modelo Eloquent.

El atributo **$fillable** especifica los campos que pueden ser asignados masivamente (por ejemplo, cuando se crea o se actualiza un registro en la tabla de **"Provincias"**).

El trait HasFactory proporciona una forma conveniente de crear nuevos registros en la tabla utilizando fábricas, lo que puede ser útil en desarrollo y pruebas.

Con este modelo, puedes interactuar con la tabla **"provincias"** en la base de datos usando las capacidades de Laravel. Por ejemplo, puedes consultar registros existentes o crear nuevos registros con una llamada simple al modelo:

```js
$provincia = new Provincia();
$provincia->codigo = '01';
$provincia->nombre = 'Buenos Aires';
$provincia->save();
```
También puedes consultar registros existentes de la tabla de "Provincias" de la siguiente manera:

```js
$provincias = Provincia::all();
Esto te dará una colección de todos los registros en la tabla "provincias".
```
### Poblacion

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Poblacion
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Poblacion"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Poblacion.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Poblacion extends Model
{
    use HasFactory;
    protected $table="poblaciones";
    protected $fillable = ['codigo','nombre'];
    
}
```
Este es una definición de clase PHP para un modelo Eloquent en el marco de trabajo Laravel. La clase se llama **"Poblacion"** y extiende la clase **"Model"**
incorporada. La clase representa una tabla de base de datos **"poblaciones"** y especifica qué columnas en esa tabla se pueden llenar con datos (la propiedad **"fillable"**) - en este caso, **"codigo"** y **"nombre"**.

### Proveedor

Ejecute el siguiente comando en su terminal:

```bash
php artisan make:model Proveedor
```

Una vez ejecutado el comando, diríjase a la carpeta **App/Models** y edite el fichero **"Proveedor"**. Substituya el código generado por el siguiente código:

```js title="app\Models\Proveedor.php"
<?php

namespace App\Models;

use Illuminate\Database\Eloquent\Factories\HasFactory;
use Illuminate\Database\Eloquent\Model;

class Proveedor extends Model
{
    protected $table="proveedores";
    use HasFactory;
    protected $fillable = [
        'nif',
        'nombre',
        'cod_postal',
        'cod_provincia',
        'calle',
        'numero',
        'notas'
    ];
    public function productos(){
        return $this->BelongsToMany('App\Models\Producto');
    }
}
```
Este es un modelo de Laravel para una tabla de **"Proveedores"**. La clase extiende de Illuminate\Database\Eloquent\Model, lo que significa que está siendo utilizada como un modelo Eloquent.

El atributo **$table** especifica el nombre de la tabla en la base de datos a la que está asociada este modelo.

El atributo **$fillable** especifica los campos que pueden ser asignados masivamente (por ejemplo, cuando se crea o se actualiza un registro en la tabla de "Proveedores").

El trait HasFactory proporciona una forma conveniente de crear nuevos registros en la tabla utilizando fábricas, lo que puede ser útil en desarrollo y pruebas.

El método productos define una relación **"muchos a muchos"** con la tabla **"Productos"**. Esta relación significa que un proveedor puede proporcionar múltiples productos y un producto puede ser proporcionado por múltiples proveedores.

Con este modelo, puedes interactuar con la tabla **"proveedores"** en la base de datos usando las capacidades de Laravel. Por ejemplo, puedes consultar registros existentes o crear nuevos registros con una llamada simple al modelo:

```js 
$proveedor = new Proveedor();
$proveedor->nif = '12345678A';
$proveedor->nombre = 'Proveedor S.A.';
$proveedor->cod_postal = '1234';
$proveedor->cod_provincia = '01';
$proveedor->calle = 'Calle 1';
$proveedor->numero = '1';
$proveedor->notas = 'Notas adicionales';
$proveedor->save();
```

También puedes consultar registros existentes de la tabla de "Proveedores" de la siguiente manera:

```js
$proveedores = Proveedor::all();
```

Esto te dará una colección de todos los registros en la tabla "proveedores". Además, puedes acceder a los productos asociados con un proveedor determinado de la siguiente manera:

```js
$proveedor = Proveedor::find(1);
$productos = $proveedor->productos;
```

Esto te dará una colección de todos los productos asociados con el proveedor con id 1.
